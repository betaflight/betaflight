;
; Copyright (c) TODO
;

; DSHOT protocol rate (150, 300, 600) is dynamic
; DSHOT bidir / not bidir is compiled in
; For rate, could have separate programs ready to load in (maybe easiest)
;  or could have effectively dynamic based on contents of x register if spare, which can be
; set with pio_sm_exec_wait_blocking
; For >4 motors, could configure pin with disable, config set, enable, [but run out of time in gyro loop? might need another PIO for more SMs]
;

; presumably BF writes dshot async, at max of ~10k/sec or so (typical aiming for 8k loop for gyro)
; dshot frame takes approx. 0.1ms dshot150 or dshot300_bidir
; so hopefully never going to be overflowing the tx fifo (but could happen with 150bidir and be close with 150, 300bidir)


; programs dshot_150, dshot_300, dshot_600, dshot_bidir_150, dshot_bidir_300, dshot_bidir_600
;
; All programs, bit width = 40 cycles, clock set accordingly
; Min delay between frames of 2us, number of cycles varies according to program

; DSHOT 600
; 1 bit ~ 1.667us, 2us ~ 48 cycles. Allow say 56 cycles between frames
;
; * could get rid of nop by adding delays to 2x jmp !osre, bitloop
; * maybe get rid of discard by writing 16-bit word (dupllicated to top 16 bits), and osre empty after 16 bits
;
; could be simpler to let the PIO "bitbang" bytes of 11111100 or 11100000 (which have the correct ratios
; of 6:2 and 3:5 to represent 1 and 0). The 4-word TX fifo has enough space (4x32 bits = 16 bytes) for the 16 dshot bits required.

.program dshot_600
start:
    set    pins, 0                [31]      ; Set pin low [assumed pin already set for output]
    nop                           [20]      ; min delay 2us at DSHOT600 is 48 cycles, allow 56 before next set
    pull   block                            ; Block until someone puts something into the TX FIFO
    out    y, 16                            ; Discard top 16 bits
bitloop:
    out    y, 1                             ; Shift next bit into y
    jmp    !y, outzero                      ;
    set    pins, 1                [29]      ; To output a '1' bit, set high for 30 then low for 10 (based on bitlength = 40 cycles)
    set    pins, 0                [6]       ; Delay to next "set" adds up to 10
    jmp    !osre, bitloop                   ; If not done output (finished shifting bits) then loop
    jmp    start
outzero:
    set    pins, 1                [13]      ; To output a '0', set high for 14 then low for 26
    set    pins, 0                [21]      ; Delay to next "set" adds up to 26
    jmp    !osre, bitloop         [1]       ; If not done output (finished shifting bits) then loop else wrap to start



; DSHOT 600 bidir
; 1 output bit ~ 1.667us = 40 PIO cycles
; 1 PIO cycle is ~ 0.042us = 6.25 sys clock cycles (at 150MHz) [so a little bit of jitter at the 1-PIO-cycle level]
; 2us ~ 48 cycles. Allow say 56 cycles between frames
; NB output levels are inverted compared to DSHOT
; For input, do 3x oversampling of the 21 bits, which necessarily start with a 0 bit
; hence pushing 63 bits of info, or 60 with the first 0 taken as read
; so in 2x (30 bits of a 32-bit word)
; input bit rate is 5/4 times output, so 32 PIO cycles
;
; receive: wait for 0, assuming it is held at 1 until ESC responds
; hopefully this does the trick gpio_set_pulls(pin, true, false); // Pull up - idle 1 when awaiting bidir telemetry input (PIO pindirs 0).
; Expect to receive frame 30us (independent of DSHOT speed) after output frame.
; Put in a delay of say ~ 25us to allow time for ESC, PIO to change direction of transmission, settle down electrically etc.
; and not risk missing the start of the receive frame.
; At DSHOT 600, 25us is 15 bits or 15*40 = 600 = 25*24 clocks [or 30 * 20)
; Receive bit rate is at 40 * 5/4 = 32 PIO cycles
; sample at ~ 1/6, 1/2, 5/6 after start of packet
; so say at cycles 6, 16, 26 of 0..31
; interval between detecting initial transition to zero and first sample of second bit = 32 + 6 = 38 cycles
; thereafter intervals between reads of 10, 10, 12

.program dshot_600_bidir_debug
.side_set 1
start:
    set    pindirs, 1     side 0            ; Set pins for output
    set    pins, 1        side 0  [15]      ; Set pin high
    nop                   side 0  [15]      ; min delay 2us at DSHOT600 is 48 cycles, allow 52 before next set
    nop                   side 0  [15]
    pull   block          side 1            ; Block until someone puts something into the TX FIFO
    out    y, 16          side 0            ; Discard top 16 bits
bitloop:
    out    y, 1           side 0            ; Shift next bit into y
    jmp    !y, outzero    side 0            ;
outone:
    set    pins, 0        side 0  [15]      ; To output a '1' bit, set low for 30 then high for 10 (based on bitlength = 40 cycles)
    nop                   side 0  [13]
    set    pins, 1        side 0  [6]       ; Delay to next "set" adds up to 10
    jmp    !osre, bitloop side 0            ; If not done output (finished shifting bits) then loop
    jmp    receive        side 0
outzero:
    set    pins, 0        side 0  [14]      ; To output a '0', set low for 15 then high for 25
    set    pins, 1        side 0  [15]      ; Delay to next "set" adds up to 25
    jmp    !osre, bitloop side 0  [6]       ; If not done output (finished shifting bits) then loop else wrap to start
;;;;;;; (dropped because short of instruction space)   nop                                     ; line up timings vs. arriving at receive from outone
receive:
    set    pindirs, 0     side 0
    set    x, 19          side 0
delay_loop:
    nop                   side 0  [14]
    jmp    x--, delay_loop side 0 [14]
    wait   0 pin, 0       side 1  [2]      ; Receive telemetry: wait for zero on input pin with index 0 (the only input pin)
    nop                   side 0  [15]
    set    x, 1           side 0  [15]       ; Loop two words, ensure delay to first read (in pins) is 38<--- TBC ***
in_wordloop:
;;;;;;;;    nop     ;;;;;;    in     NULL, 2                      ; 2 bits of padding to go with 10x 3 bits per word (not required, but makes it cleaner)
    set    y, 9           side 0  [1]      ; Want to retrieve 10 lots of 3 bits [twice over with word loop]
    jmp    in_bitloop_catchup side 0       ; Synchronise with the y loop path
in_bitloop:
    nop                   side 0  [4]
in_bitloop_catchup:
    in     pins, 1        side 1  [9]       ; T+6
    in     pins, 1        side 0  [9]       ; T+16
    in     pins, 1        side 1  [5]       ; T+26
    jmp    y--, in_bitloop side 0
    push   noblock        side 0           ; Received 2 + 10*3 = 32 bits, push to RX fifo
    jmp    x--, in_wordloop side 0          ; Loop for 2nd word if not done yet
    ; wrap                                  ; Done receiving telemetry bits, restart



.program dshot_600_bidir
start:
    set    pindirs, 1                       ; Set pins for output
    set    pins, 1                [30]      ; Set pin high
    nop                           [20]      ; min delay 2us at DSHOT600 is 48 cycles, allow 56 before next set
    pull   block                            ; Block until someone puts something into the TX FIFO
    out    y, 16                            ; Discard top 16 bits
bitloop:
    out    y, 1                             ; Shift next bit into y
    jmp    !y, outzero                      ;
outone:
    set    pins, 0                [29]      ; To output a '1' bit, set low for 30 then high for 10 (based on bitlength = 40 cycles)
    set    pins, 1                [6]       ; Delay to next "set" adds up to 10
    jmp    !osre, bitloop                   ; If not done output (finished shifting bits) then loop
    jmp    receive
outzero:
    set    pins, 0                [14]      ; To output a '0', set low for 15 then high for 25
    set    pins, 1                [20]      ; Delay to next "set" adds up to 25
    jmp    !osre, bitloop         [1]       ; If not done output (finished shifting bits) then loop else wrap to start
    nop                                     ; line up timings vs. arriving at receive from outone
receive:
    set    pindirs, 0
    set    x, 23
delay_loop:
    jmp    x--, delay_loop        [24]
    wait   0 pin, 0               [31]      ; Receive telemetry: wait for zero on input pin with index 0 (the only input pin)
    set    x, 1                   [2]       ; Loop two words, ensure delay to first read (in pins) is 38
in_wordloop:
    nop     ;;;;;;    in     NULL, 2                      ; 2 bits of padding to go with 10x 3 bits per word (not required, but makes it cleaner)
    set    y, 9                             ; Want to retrieve 10 lots of 3 bits [twice over with word loop]
    jmp    in_bitloop_catchup               ; Synchronise with the y loop path
in_bitloop:
    nop                           [4]
in_bitloop_catchup:
    in     pins, 1                [9]       ; T+6
    in     pins, 1                [9]       ; T+16
    in     pins, 1                [5]       ; T+26
    jmp    y--, in_bitloop
    push   noblock                          ; Received 2 + 10*3 = 32 bits, push to RX fifo
    jmp    x--, in_wordloop                 ; Loop for 2nd word if not done yet
    ; wrap                                  ; Done receiving telemetry bits, restart

; pio_sm-restart
; This method clears the ISR, shift counters, clock divider counter pin write flags, delay counter, latched EXEC instruction, and IRQ wait condition.
;     hw_set_bits(&pio->ctrl, 1u << (PIO_CTRL_SM_RESTART_LSB + sm));
; Specifically, the following are cleared: input and output shift counters; the
; contents of the input shift register; the delay counter; the waiting-on-IRQ state;
; any stalled instruction written to SMx_INSTR or run by OUT/MOV EXEC; any
; pin write left asserted due to OUT_STICKY.
;
; - doesn't reset PC!
